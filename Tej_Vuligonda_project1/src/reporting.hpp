// ICS 46 Summer 2015
// Project 1
//
// This file contains functions for testing the sorting functions you have
// implemented in sorting.hpp. You should not modify this file.
//
#ifndef __REPORTING_HPP__
#define __REPORTING_HPP__
#include "sorting.hpp"
#include <algorithm>
#include <random>
#include <ctime>

// Function type for sorting function
template <typename T>
using sorter_t = decltype(&insertion_sort<T>);


// Times sorting. Returns -1 if sorting failed.
template <typename T>
double time_sorting(sorter_t<T> sorter, const std::vector<T>& input)
{
    std::vector<T> vector = input;

    auto start = clock();
    sorter(vector);
    auto stop = clock();

    double ret =  1000 * static_cast<double>(stop - start) / CLOCKS_PER_SEC;
    if (is_sorted(vector) == false) ret = -1.0;

    return ret;
}

// Generate a random vector of length n
// uniformly from all n! permutations
std::vector<int> generate_random(size_t n)
{
    std::random_device rd;
    std::default_random_engine eng(rd());
    std::vector<int> vector(n);
    for (int i = 0; i < n; i++) vector[i] = i;
    std::shuffle(vector.begin(), vector.end(),eng);

    return vector;
}

// Generate an almost sorted vector of length n
// by starting with a sorted list and randomly 
// swapping pairs of elements k times
std::vector<int> generate_almost_sorted_1(size_t n)
{
    int k = 100;
    std::random_device rd;
    std::default_random_engine eng(rd());
    std::uniform_int_distribution<int> dis(0, n-1);

    std::vector<int> vector(n);
    for (int i = 0; i < n; i++) vector[i] = i;

    for (int i = 0; i < k; i++) vector[dis(eng)] = dis(eng);

    return vector;
}

// Generate an almost sorted vector of length n
// by starting with a sorted list and randomly
// swapping adjacent pairs of elements k*n times
std::vector<int> generate_almost_sorted_2(size_t n)
{
    int k = 250;
    std::random_device rd;
    std::default_random_engine eng(rd());
    std::uniform_int_distribution<int> dis(0, n-2);

    std::vector<int> vector(n);
    for (int i = 0; i < n; i++) vector[i] = i;

    for (int i = 0; i < k*n; i++) 
    {
        int j = dis(eng);
        std::swap(vector[j],vector[j+1]);
    }

    return vector;
}

// Formatted printing of times 
void formatted_print(std::vector<unsigned int> sizes, std::vector<double> times)
{
    for (int i = 0; i < sizes.size(); i++)
    {
        std::cout << sizes[i] << "\t: ";
        if (times[i] >= 0)
        {
            std::cout << times[i];
        }
        else
        {
            std::cout << "Failed to sort vector!";
        }
        std::cout << std::endl;
    }
}

using generator = decltype(&generate_random);
// Run a test of a single sorter and generator pair
double sort_time(sorter_t<int> sorter, unsigned int num_runs, unsigned int size, generator gen)
{
    double sum = 0.0;
    for (int i = 0; i < num_runs; i++) {
        // Time sorter on a list from the generator
        auto input = gen(size);
        sum += time_sorting(sorter,input);
    }
    double avg = sum / num_runs;
    return avg;
}

// Print a timing report of the time the sorting algorithms in sorters take to sort the 
// list generated by the generators in gens of the sizes in sizes
void sorting_report(std::vector<sorter_t<int>> sorters, std::vector<std::string> sorter_names,
        unsigned int num_runs, std::vector<unsigned int> sizes, std::vector<generator> gens, 
        std::vector<std::string> gen_names)
{
    // For each sorter, generator, and size run a test
    for (int i = 0; i < sorters.size(); i++)
    {
        std::cout << "=====" << sorter_names[i] << "=====" << std::endl;
        sorter_t<int> sorter = sorters[i];
        for (int j = 0; j < gens.size(); j++)
        {
            std::vector<double> times = std::vector<double>(sizes.size());
            std::cout << gen_names[j] << " (size : time)" << std::endl;
            generator gen = gens[j];
            for (int k = 0; k < sizes.size(); k++)
            {
                unsigned int size = sizes[k];
                double time = sort_time(sorter, num_runs, size, gen);
                times[k] = time;
            }
            // Print the test results for this sorter and generator
            formatted_print(sizes,times);
        }
    }
}

#endif // __REPORTING_HPP__
